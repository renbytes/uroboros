import logging
from typing import List, Any
from pydantic import BaseModel, Field

from uroboros.llm.client import LLMClient
from uroboros.core.config import get_settings

logger = logging.getLogger(__name__)
settings = get_settings()

class FuzzInput(BaseModel):
    """Represents a specific input vector to test."""
    input_value: str
    description: str = Field(..., description="Why this input might break the code")
    input_type: str = Field(..., description="int, string, json, etc.")

class FuzzSuite(BaseModel):
    """A collection of inputs generated by the LLM."""
    cases: List[FuzzInput]

class LLMFuzzer:
    """
    Generates semantic edge cases based on function signatures.
    Research Ref: Generative Adversarial Software Testing (GAST).
    """

    def __init__(self):
        # We use the Adversary model (usually equal to or stronger than Actor)
        self.llm = LLMClient(model_name=settings.ADVERSARY_MODEL)

    async def fuzz_signature(self, code_snippet: str, num_cases: int = 5) -> List[FuzzInput]:
        """
        Analyzes a code snippet (function signature) and generates inputs 
        likely to cause crashes or logic errors.
        """
        logger.info(f"Fuzzing target code ({len(code_snippet)} chars)...")

        system_prompt = """
You are an Intelligent Fuzzer. 
Your goal is to generate inputs that will CRASH or exploit the provided code.

Target specific vulnerabilities:
- Off-by-one errors (integers).
- SQL Injection / Command Injection (strings).
- Path traversal (filenames).
- Null/None/Empty values.
- Type mismatches.
- Resource exhaustion (huge inputs).
"""

        user_prompt = f"""
### Target Code:
{code_snippet}

### Instruction:
Generate {num_cases} distinct fuzzing inputs for the primary function in the code above.
Return them as a structured list.
"""

        try:
            result = await self.llm.chat_structured(
                system_prompt=system_prompt,
                user_prompt=user_prompt,
                response_model=FuzzSuite
            )
            
            logger.info(f"Generated {len(result.cases)} fuzz cases.")
            return result.cases

        except Exception as e:
            logger.error(f"Fuzzing failed: {e}")
            return []

    def format_as_pytest_params(self, fuzz_cases: List[FuzzInput]) -> str:
        """
        Helper to convert fuzz inputs into a @pytest.mark.parametrize string.
        """
        # TODO: make more robust
        # This is a heuristic; robust implementation would require AST parsing
        # to match arguments. Here we return a simple list string.
        param_list = [f"('{c.input_value}') # {c.description}" for c in fuzz_cases]
        return "[\n    " + ",\n    ".join(param_list) + "\n]"